{"meta":{"title":"Good day to code","subtitle":"거 코딩하기 딱 좋은 날씨네","description":"","author":"hwanhee jo","url":"https://johwanhee.github.io","root":"/"},"pages":[{"title":"","date":"2020-05-04T19:43:17.887Z","updated":"2020-05-04T19:43:17.876Z","comments":true,"path":"categories/index.html","permalink":"https://johwanhee.github.io/categories/index.html","excerpt":"","text":"type: categories"},{"title":"about","date":"2020-05-04T19:42:36.000Z","updated":"2020-05-04T19:42:36.240Z","comments":true,"path":"about/index.html","permalink":"https://johwanhee.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-04T19:42:39.000Z","updated":"2020-05-04T19:42:39.774Z","comments":true,"path":"tags/index.html","permalink":"https://johwanhee.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"prj/flutter","slug":"prj/flutter","date":"2020-05-05T14:53:48.264Z","updated":"2020-05-05T14:53:48.264Z","comments":true,"path":"2020/05/05/prj/flutter/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/prj/flutter/","excerpt":"","text":"플러터로 개발하기작년말 이사님의 추천(?)으로 올해 팀즈에서 플러터를 이용한 앱을 만들어보기로했습니다.큰 주제는 머테리얼 디자인 가이드와 플러터 학습으로 방향을 잡고 실제 서비스할 수 있는 앱을 런칭하는 것까지 목표를 세웠습니다.이번 프로젝트에서 플루터를 통해 개발 하면서 느낀 주제들(머테리얼 가이드, UI 개발, 크로스플랫폼, 생산성)에 대해 이야기해볼까합니다. 머테리얼 디자인 가이드플러터는 구글에서 개발하고 있는 프레임워크이며 머테리얼 디자인 가이드또한 구글에서 제시하는 UI 디자인 가이드다보니,프레임워크차원에서 머테리얼 디자인 가이드에 맞춰 개발을 진행할 수 있는 점이 상당히 매력적으로 다가왔습니다. 다음은 플러터에서 제시하는 앱 테마 코드와 구글 머테리얼 디자인 가이드입니다.1234567891011121314151617181920static Color lightPrimary = HexColor.fromHex(\"fdfdfd\");static Color lightPrimaryLight = HexColor.fromHex(\"ffffff\");static Color lightPrimaryDark = HexColor.fromHex(\"faf8f6\");static Color lightAccent = HexColor.fromHex(\"ff9e00\");static Color lightAccentLight = HexColor.fromHex(\"ffd69b\");static Color lightAccentDark = HexColor.fromHex(\"ec8102\");static ThemeData lightTheme = ThemeData( fontFamily: \"NotoSans\", backgroundColor: lightBG, accentColor: lightAccent, primaryColorLight: lightPrimaryLight, primaryColorDark: lightPrimaryDark, primaryColor: lightPrimary, primaryIconTheme: IconThemeData( color: HexColor.fromHex(\"c4c4c4\") ), // 중략); 처음에는 생소한 디자인 가이드라 그런지 저도 그렇고 디자이너님도 그렇고 어떤식으로 방향을 잡아야할지 난항을 겪었으나,이후 개발을 직접 진행하면서는 전체적인 스타일이 다 잡힌 상태로 개발을 하는거라 그런지 코드양이 확실히 많이 줄고 새로운 컴포넌트를 추가할때도 편리하다는 장점이 있었습니다.또한 테마변경 기능이 제공되어 다크테마 / 라이트테마 적용을 정말 색상값만 추가해주기만해도 바로 적용되는 모습을 봤을 때 감격을 눈물을 감출 수 없었습니다. UI 개발플러터는 UI를 코드로 그립니다. 아래 처럼요 123456789101112131415161718return Scaffold( body: SafeArea( child: Center( child: ListView( shrinkWrap: true, padding: EdgeInsets.only(left: 20.0, right: 20.0), children: &lt;Widget&gt;[ email, SizedBox(height: 8.0), password, SizedBox(height: 24.0), loginButton, ], ), ), ), ); 윈도우의 XAML, 안드로이드의 XML, 웹의 HTML등 마크업으로 진행하는 UI작업에 너무 익숙해져있던지라 처음에는 굉장히 불편하고 예전 JAVA의 SWING을 떠올리기도 했습니다. 개발하다보니 이는 굉장히 큰 장점으로 다가왔습니다. UI에 로직을 추가하는 일, 데이터 바인딩을 하는 일 등을 마크업과 코드를 왔다갔다하지않고 Dart코드 하나로 모두 처리할 수 있어 개발속도를 높일 수 있었습니다. 그리고 가장 큰 장점으로 &lt;!-- UI에 주석을 이처럼 달지않고 --&gt; //이와같이 달 수 있습니다! 크로스 플랫폼크로스 플랫폼은 오히려 단점으로 다가왔습니다. 라이브러리 하나를 추가하려면 ios / android 하나 하나 확인해가며 라이브러리 수정을 해야하거나 각기 다른 환경설정을 넣어줘야했고 이후에는 라이브러리 추가하는일이 “상당히 귀찮은 일”로 자리잡게 되었습니다.또한 ios와 android모두 지향하는 ux부분이 다른데, 플루터는 one code base로 진행되다보니 ios, android가 정체성없는 ux가 나오는 점이 제게는 큰 단점으로 다가왔습니다.코드내에서 ios android 플랫폼 검사를하여 view를 다르게 보여줄 수 도있는데, 이는 크로스플랫폼이 추구하는 방향은 아니라고 생각되어 적용해보진 않았습니다. 생산성확실히 앱 개발속도는 빠릅니다. 특히나 hot reload의 runtime debuging 기능은 java를 통한 android 개발과는 차원이 다른 수준의 디버깅 경험을 선사해주었습니다.집에선 flutter를 하고 사무실에선 android를 하는데, 사무실에서 작업할때마다 얼른 퇴근하고싶다(?)는 생각이 들게끔 해주는 정도였습니다. 결론, 플러터 장점과 단점장단점을 논하기엔 짧은 기간의 개발이라 조심스럽고 섣부른 판단일수도있습니다만,플러터 자체적으로는 실무에 적용하기에 적당히 고려해볼수도있으나 크로스플랫폼앱을 실무에 적용하는건 무리가 있을것이라 판단됩니다. 그런데 만약 크로스플랫폼을 도입하기로 결정이 된 상태이며 RN/xamarin/flutter중 하나를 고려해야한다면, flutter는 좋은 선택이 될것이라 생각됩니다. 장점 생산성/디버깅 핫 리로딩은 진짜 환상적임.. 라이브러리 생각보다 라이브러리가 많고 라이브러리 가져다쓰기가 편함 https://pub.dev/ 디자인 머테리얼 디자인이 최적화 되어있고 코드베이스에서 디자인 가이드 적용을 지원함 단점 디자인 주관적인 의견이지만 ios android 모두 하나의 ux로 가는건 최악이라고 생각함 (사실 이는 모든 크로스플랫폼을 부정하는 것이라..) android용 ios용으로 알아서 view가 변경되는 그런 기술이 나온다면 좋을 것 같음 라이브러리 장점이자 단점인데, 라이브러리 적용할때마다 각 플랫폼별로 설정체크를 해주거나 심할경우 네이티브를 작성해야함","categories":[],"tags":[]},{"title":"books/객체지향의 사실과 오해 책 정리 1장","slug":"books/객체지향의 사실과 오해 책 정리 1장","date":"2020-05-05T14:53:48.263Z","updated":"2020-05-05T14:53:48.263Z","comments":true,"path":"2020/05/05/books/객체지향의 사실과 오해 책 정리 1장/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/books/%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%E1%84%8B%E1%85%B4%20%E1%84%89%E1%85%A1%E1%84%89%E1%85%B5%E1%86%AF%E1%84%80%E1%85%AA%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%A2%20%E1%84%8E%E1%85%A2%E1%86%A8%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%201%E1%84%8C%E1%85%A1%E1%86%BC/","excerpt":"","text":"객체지향의 사실과 오해객체지향은 실세계를 직접적이고 직관적으로 모델링할 수 있는 패러다임. 협력 하는 사람들 카페테리아의 아침아침시간의 카페테리아는 항상 부족한 카페인을 채우려는 손님들의 아우성과 손님들이 마실 카페인을 제공하기 위해 ㅏ삐 움직이는 캐시어와 바리스타의 열정으로 가득찬다. 손님은 커피를 주문하고 / 캐시어는 주문을 받고 / 바리스타는 커피를 제조한다 / 커피는 다시 캐시어에게 / 캐시어는 다시 손님에게 이 과정속 손님 캐시어 바리스타의 암묵적인 협력 관계가 존재 손님 캐시어 바리스타라는 역할이 존재 이 셋은 협력하는 과정속에 자신이 맡은 바 책임을 다한다. 요청과 응답으로 구성된 협력문제 해결에 필요한 지식을 알고있거나 서비스를 제공해줄 수 있는 사람에게 도움을 요청한다. 요청은 연쇄적으로 발생한다. 손님 &gt; (커피를 주문한다) &gt; 캐시어 &gt; (커피를 제조하라) &gt; 바리스타요청받은 사람은 주어진 책임을 다하면서 다른 사람의 요청에 응답한다. 응답역시 연쇄적으로 전달된다. 손님 &lt; (커피완성) &lt; 캐시어 &lt; (커피완성) &lt; 바리스타 역할, 책임, 협력객체의 역할은 사람의 역할과 유사하게 다음과 같은 특징을 지닌다. 여러 객체가 동일한 역할을 수행할 수 있다. 역할은 대체 가능성을 의미한다. 각 객체는 책임을 수행하는 방법을 자율적으로 선택할 수 있다. 하나의 객체가 동시에 여러 역할을 수행할 수 있다. 협력 속에 사는 객체객체지향 애플리케이션의윤곽을 결정하는 것은 역할, 책임, 협력이지만 실제로 협력에 참여하는 주체는 객체다. 만약 실행중인 애플리케이션의 내부를 눈으로 직접 볼 수 있다면 그 안에는 쉴새없이 메시지를 주고 받으며 협력하는 객체가 존재한다는 것을 확인할 수 있을것이다. 객체는 충분히 협력적이어야 한다. 객체는 충분히 자율적이어야한다. 객체는 애플리케이션의 기능을 구현하기 위해 존재한다. 객체지향 애플리케이션의 아름다움을 결정하는 것이 협력이라면 협력이 얼마나 조화를 이루는지 결정하는 것은 객체다. “외부의 도움을 무시한 채 모든 것을 스스로 처리하려고 하는 전지전능한 객체는 내부적인 복잡도에 의해 자멸하고 만다.” 상태와 행동을 함께 지닌 자율적인 객체객체가 협력에 참여하기 위해 어떤 행동을 해야한다면 그 행동을 하는 데 필요한 상태도 함게 지니고 있어야 한다는 것을 의미한다. 객체가 협력에 참여하는 과정 속에서 스스로 판단하고 스스로 결정하는 자율적인 존재로 남기 위해서는 필요한 행동과 상태를 함께 지니고 있어야한다. 객체는 다른 객체가 ‘무엇’을 수행하는지는 알 수 있지만 ‘어떻게’ 수행하는지에 대해서는 알 수 없다. 객체지향의 본질 객체지향이란 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고 객체를 이용해 시스템을 분할하는 방법이다. 자율적인 객체란 상태와 행위를 함께지니며 스스로 자기 자신을 책임지는 객체를 의미한다. 객체는 시스템의 행위를 구현하기위해 다른 객체와 협력한다. 각 객체는 협력 내에서 정해진 역할을 수행하며 역할은 관련된 책임의 집합이다. 객체는 다른 객체와 협력하기 위해 메세지를 전송 메시지를 수신한 객체는 메시지를 처리하는 데 적합한 메서드를 자율적으로 선택한다. 1234훌륭한 객체지향 설계자가 되기 위해 거쳐야 할 첫 번째 도전은 코드를 담는 클래스의 관점에서 메시지를 주고받는 객체의 관점으로 사고의 중심을 전환하는 것이다.클래스의 구조와 메서드가 아니라 객체의 역할, 책임, 협력에 집중하라. 객체지향은 객체를 지향하는 것이지 클래스를 지향하는 것이 아니다.","categories":[],"tags":[]},{"title":"books/객체지향의 사실과 오해 책 정리 2장","slug":"books/객체지향의 사실과 오해 책 정리 2장","date":"2020-05-05T14:53:48.263Z","updated":"2020-05-05T14:53:48.263Z","comments":true,"path":"2020/05/05/books/객체지향의 사실과 오해 책 정리 2장/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/books/%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%E1%84%8B%E1%85%B4%20%E1%84%89%E1%85%A1%E1%84%89%E1%85%B5%E1%86%AF%E1%84%80%E1%85%AA%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%A2%20%E1%84%8E%E1%85%A2%E1%86%A8%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%202%E1%84%8C%E1%85%A1%E1%86%BC/","excerpt":"","text":"객체지향과 인지능력 고개를 들어 주위를 둘러보면 객체라고 부를 수 있는 다양한 존재를 볼 수 있다. 길을 걷는 사람들 도로위를 미끄러지듯 지나가는 자동차 도시의 적막함을 감싸주는 푸른 가로수 책상위에 놓여진 컴퓨터와 모니터 하나의 단위로 인식할 수 있고 다른 사물과 구분할 수 있는 모든것들이 모여 객체의 스펙트럼을 형성한다. 추상적인 사물까지도 객체로 인식할 수 있게한다. 오늘의 주문 내역 어제의 주문내역 주문과 계좌이체 객체지향 패러다임의 목적은 현실 세계를 모방하는 것이 아니라 현실 세계를 기반으로 새로운 세계를 창조하는것이다. 앨리스 객체 엘리스의 상태를 결정하는 것은 행동이지만 행동의 결과를 결정하는 것은 상태다. 어떤 행동의 성공 여부는 이전에 어떤 행동들이 발생했는지에 영향을 받는다. 앨리스의 특징 앨리스는 상태를 가지며 상태는 변경 가능하다. 앨리스의 상태를 변경 시키는 것은 앨리스의 행동이다. 행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다. 행동의 순서가 결과에 영향을 미친다. 앨리스는 어떤 상태에 있더라도 유일하게 식별 가능하다. 객체 다른 사물과 구분할 수 있으며, 생성 시점을 알 수 있고, 독립적인 하나의 단위로 인식할 수 있는 모든 사물은 객체다. 객체의 다양한 특성을 효과적으로 설명하기 위해서는 객체를 ₩상태(state), 행동(behavior), 식별자(identity)₩를 비닌 실체로 보는 것이 가장 효과적이다. 상태 여행을 위해 비행기를 이용하려면 탑승 전 항공권을 발생했느냐에 따라 좌우된다. 비행기 탑승 여부는 과거에 항공권을 발권하는 행동이 발생했는지 여부에 따라 달라지는 것이다. 상태는 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현한다. 객체의 상태는 객체에 존재하는 정적인 프로퍼티와 동적인 프로퍼티 값으로 구성된다. 객체의 프로퍼티는 단순한 값과 다른 객체를 참조하는 링크로 구분할 수 있다. 행동 객체의 행동은 상태에 영향을 받는다 : 상호작용이 현재의 상태에 어떤 방식으로 의존하는가. 객체의 행동은 상태를 변경시킨다 : 상호작용이 어떻게 현재의 상태를 변경시키는가. 행동이란 외부의 요청 또는 수신된 메세지에 응답하기 위해 동작하고 반응하는 활동이다. 행동의 결과로 객체는 자신의 항태를 변경하거나 다른 객체에게 메세지를 전달할 수 잇다. 객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 외부에 가시적이어야한다.","categories":[],"tags":[]},{"title":"books/객체지향의 사실과 오해 책 정리 4장","slug":"books/객체지향의 사실과 오해 책 정리 4장","date":"2020-05-05T14:53:48.263Z","updated":"2020-05-05T14:53:48.263Z","comments":true,"path":"2020/05/05/books/객체지향의 사실과 오해 책 정리 4장/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/books/%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%E1%84%8B%E1%85%B4%20%E1%84%89%E1%85%A1%E1%84%89%E1%85%B5%E1%86%AF%E1%84%80%E1%85%AA%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%A2%20%E1%84%8E%E1%85%A2%E1%86%A8%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%204%E1%84%8C%E1%85%A1%E1%86%BC/","excerpt":"","text":"역할, 책임, 협력우리 모두를 합친 것보다 더 현명한 사람은 없다. 협력협력의 본질은 요청과 응답으로 연결되는 사람들의 네트워크다. 일반적으로 우리가 직면하게 되는 문제는 혼자만의 힘으로는 해결하기 어렵기 때문에 해결 과정에 여러 사람이 참여하게 된다. 이 과정 속에서 요청과 응답의 연쇄적인 흐름이 발생한다. 협력은 한 사람이 다른 사람에게 도움을 요청할 때 시작된다. 요청을 받은 사람은 일을 처리한 후 요청한 사람에게 필요한 지식이나 서비스를 제공하는 것으로 요청에 응답한다. 결과적으로 협력은 다수의 요청과 응답으로 구성되며 전체적으로 협력은 다수의 연쇄적인 요청과 응답의 흐름으로 구성된다. 개인적으로 연쇄적인 요청과 응답이 많아질수록 애플리케이션의 복잡도가 증가한다고 생각함. 코드의 가독성이 오히려 떨어지는 경우를 자주 봄 재판속의 협력 누군가가 왕에게 재판을 요청 왕이 하얀 토끼에게 증인을 부를것을 요청 토끼는 모자장수에게 증인석으로 입장할것을 요청 모자장수는 증인석에 입장 함으로써 응답 왕은 모자장수에게 증언할 것을 요청 모자장수는 자신이 알고있는 내용을 증언함으로써 왕의 요청에 응답 1234567891011121314151617181920212223242526272829303132333435363738394041class 누군가 &#123; public void 재판요청로직() &#123; 왕 w = new 왕(); 재판결과 결과 = 왕.재판하라(); if(결과 == \"유죄\") &#123; // todo &#125; else if (결과 == \"무죄\") &#123; // todo &#125; &#125;&#125;class 왕 &#123; public 재판결과 재판하라()&#123; 토끼 하얀토끼 = new 토끼(); 증인 증인 = 하얀토끼.증인을호출하라(); 증언 증언 = 증인.증언하라(); return 내부_재판(증언); &#125; private 재판결과 내부_재판(증언 증언) &#123; return 재판결과; &#125;&#125;class 토끼 &#123; public 증인 증인을호출하라()&#123; 모자장수 증인 = new 모자장수(); return 증인; &#125;&#125;class 모자장수 &#123; public 증언 증언하라()&#123; return 증언; &#125;&#125; 책임 객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에 할당하는 것 객체가 하는 것 객체를 생성하거나 계산을 하는 등의 스스로 하는 것 다른 객체의 행동을 시작시키는 것 다른 객체의 활동을 제어하고 조절 하는 것 객체가 아는 것 개인적인 정보에 관해 아는 것 관련된 객체에 관해 아는 것 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것 객체의 책임을 이야기할 때는 일반적으로 외부에서 접근 가능한 공용 서비스의 관점에서 이야기한다. 즉 아는것, 하는것만 보여준다. 따라서 책임은 객체의 공용 인터페이스를 구성한다. 설계를 시작하는 초반에는 어떤 객체가 어떤 책임을 가지고 어떤 방ㅅ핵으로 서로 협력해야 하는지에 대한 개요를 아는 것만으로도 충분하다. 역할 재판이라는 협력 과정 속에서 왕과 하트여왕은 판사 역할, 모자 장수와 요리사 그리고 엘리스는 증인역할을 수행한다. 따라서 다음과 같이 역할과 협력으로 추상화할 수 있다. 누군가 판사에게 재판을 요청 판사는 하얀 토끼에게 증인을 부를것 요청 판사의 요청을 받은 토끼는 증인에게 증인석으로 입장할 것을 요청 증인은 증인석에 입장함으로써 응답 증인의 입장은 연쇄적으로 토끼에 대한 판사의 요청에대한 응답 이제 판사는 증인에게 증언할 것을 요청 증인은 자신이 알고있는 내용을 증엏남으로써 판사의 요청에 응답 요약하면 역할의 개념을 사용하면 유사한 협력을 추상화해서 인지 과부하를 줄일 수 있다. 역할은 객체 지향 설계의 단순성, 유연성, 재사용성을 뒷받침하는 핵심 개념이다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class 누군가 &#123; public void 재판요청로직() &#123; 판사 w = new 왕(); 재판결과 결과 = 왕.재판하라(); if(결과 == \"유죄\") &#123; // todo &#125; else if (결과 == \"무죄\") &#123; // todo &#125; &#125;&#125;class 왕 implements 판사 &#123; public 재판결과 재판하라()&#123; 토끼 하얀토끼 = new 토끼(); 증인 증인 = 하얀토끼.증인을호출하라(); 증언 증언 = 증인.증언하라(); return 내부_재판(증언); &#125; private 재판결과 내부_재판(증언 증언) &#123; return 재판결과; &#125;&#125;class 여왕 implements 판사 &#123; public 재판결과 재판하라()&#123; 토끼 하얀토끼 = new 토끼(); 증인 증인 = 하얀토끼.증인을호출하라(); 증언 증언 = 증인.증언하라(); return 내부_재판(증언); &#125; private 재판결과 내부_재판(증언 증언) &#123; return 재판결과; &#125;&#125;class 토끼 &#123; public 증인 증인을호출하라()&#123; 증인 증인 = new 모자장수(); return 증인; &#125;&#125;class 모자장수 implements 증인 &#123; public 증언 증언하라()&#123; return 증언; &#125;&#125;class 엘리스 implements 증인 &#123; public 증언 증언하라()&#123; return 증언; &#125;&#125;interface 증인 &#123; 증언 증언하라();&#125;interface 판사 &#123; 재판결과 재판하라();&#125; 대체가능성 역할은 협력 안에서 구체적인 객체로 대체될 수 있는 추상적인 협력자다. 객체가 주어진 책임 이외에 다른 책임을 수행할 수도 있다는 사실에 주목하라. 흔한 오류 데이터 먼저 개발 노노! 협력에 따라 흐르는 객체의 책임에 맞춰서 개발하자. 객체에게 책임을 할당하고 나면 책임으 ㄴ객체가 와부에 제공하게 될 행동이 된다.","categories":[],"tags":[]},{"title":"prj/chatbot","slug":"prj/chatbot","date":"2020-05-05T14:53:48.263Z","updated":"2020-05-05T14:53:48.264Z","comments":true,"path":"2020/05/05/prj/chatbot/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/prj/chatbot/","excerpt":"","text":"사내프로젝트 - 챗봇 플랫폼 구현 개발자들이 pip install hiworker 명령어로 파이썬 소스를 다운받아 API key만 등록하면 메신져에 챗봇을 직접 만들 수 있다! 아, 이 어찌나 간결하고 좋은가.. 이 회고는 위의 문장을 기준으로 만들어 보게된 챗봇 플랫폼 구현에 대한 회고록이다. 개발 회고를 이렇게 열심히 쓰는건 처음이라 뭘 어찌해야할지 모르겠다..ㅎ 개발 배경 슬랙봇 API와 같은 커스터마이징 가능한 챗봇을 파이썬 스크립트형태로 사용자들에게 제공하자. 사내 메신져 사용하면서 특정 메세지만으로 회의실 예약을 하고 싶었다. 그외 부가적으로 여러 부서마다 각자 제공하는 API들을 통합했으면 싶기도해서 “다른 개발자들이 챗봇을 만들수 있게 만들자!”를 구상하게 됐다. 결과물 GIF사진 들어갈 자리 발표자료 기능정의서 개발 일정 수립서 개발회고서버개발 서버 구조 설계 오랜만에 하는 서버 개발이라 너무 신나 이것저것 찾아보고 고민하며 전체 시스템 구조를 어떻게 잡아야할까 고민을 많이했다. 이것 저것 고민하게 된 결과물의 사진은 아래와 같다. 최초 구상했던 전체 구조 생각보다 심플한 구성으로 시스템 설계가 이루어질 것 같았다. 결국 HTTP(S)만으로 각각의 트랜잭션들을 처리하게 된다. 이렇게 생각했던 이유는, 챗봇 스크립트를 flask 베이스로 제공하고 다른 개발자들에게 친숙한 HTTP통신을 제공 함으로써 각 프로토콜을 통일화하고 싶었다. 사실 이렇게하면 안 되는데.. 근데 이렇게하면 큰 문제점이 두 가지 생긴다. 이와같은 방식이면 모든 챗봇들이 공인 IP를 갖고 있어야한다. http는 tcp 베이스이긴하지만 request / response 모델을 택하고있어 현재 접속중인 chatbot을 구분하기 어렵다. 이렇게 서버 구조가 바뀌었으면 어땠을까 아니 이렇게 바뀌어야만한다. 하지만 당장의 시연이 중요했고 우선 중계서버와 챗봇 스크립트를 변경해야할 서버 구조 API Key 서버 요새 NoSQL DB에 관심이 많아 Mongo DB로 사용했고 역시나 별다른 테이블 설계에 쏟는 시간을 많이 줄일 수 있어 좋았다. 근데 이상하게 커넥션-데이터수집이 느리더라 매요청마다 커넥션을 맺게 되면 매요청마다 느릴 것 같아 Memory에 데이터를 Load하고 메모리를 가져가도록 설계했다. 중계 서버 사실 API Key 서버와 별도로 분리했어야하는데, 시간관계상 API Key 서버와 통일하여 개발했다. 얘는 각 챗봇들을 Group화 하여 특정 회사별로 제공하는 챗봇 리스트들을 따로 관리하게 하고자하는 서버다. 어떤 챗봇이 어떤 회사에 속한 챗봇인지 알려주고 또 그 챗봇이랑 클라이언트랑 중간다리 형태로 통신하게하는 서버다. HTTPS와 암호화 보안적 이슈들의 고려 없이 개발을 했으나, 프로젝트 초기에는 SHA-256 암호화와 OpenSSL 인증서를 도입하여 개발할 목적이었다. 시간이 조금 더 있었더라면 이라는 핑계로 적용해보지 못한것이 엄청난 한이다. 챗봇 스크립트 오픈소스 개발 오픈소스라하기도 민망한 챗봇 스크립트는 pypi에 등록하여 오픈소스 배포를 했다. 처음해보는 파이썬 오픈소스 배포였고 생각보다 오픈소스 배포 기반이 잘 마련되어있어 놀랐다. 역시 네이밍이.. 네이밍에대한 깊은 고민을 하지못했다. 심플하게 Command와 Token으로만 구분하였고 나름의 정책을 세웠으나 (실제 소스에는 뭔가 이상한 이름으로 들어가있다.) 클라이언트개발 WPF 개발하기 WPF개발을 이번 프로젝트 하면서 조금이나마 알게된거같다. WPF App의 생명주기,각 화면의 좌표체계, 왜 OS이름이 Windows고 왜 각각을 Window라고 칭하는지 프론트엔드 개발자 운명에도 없던 프론트엔드 개발을.. Style 파일 관리 Behind code와 MVVM 협업 기획자와의 협업 디자이너와의 협업","categories":[],"tags":[]},{"title":"Security/xss","slug":"Security/xss","date":"2020-05-05T14:53:48.262Z","updated":"2020-05-05T14:53:48.262Z","comments":true,"path":"2020/05/05/Security/xss/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/Security/xss/","excerpt":"","text":"XSS(Cross Site Scripting)지금 껏 HTTP서버 개발을 진행해왔지만, 웹 취약점에 대해 이제서야 생각해보게 된 것이 너무 부끄러워 쓰는 글이다. 만들고있는 RESTServer Lib에 추가해도 좋을 법한.. XSS란?XSS는 공격자에 의해 악의적으로 작성된 스크립트가 다른 사용자에게 전달 되는 것을 의미한다. 가볍게는 페이지를 Redirection 시키는 일을 할 수 있고, 더 나아가 세션 정보를 탈취하는 등 심각한 이슈를 초래할 수 있다. 동작원리 XSS 방어조치가 안되어있는 서버에 악의적인 스크립트를 작성하여 저장한다. 웹 서비스 이용자가 해당 스크립트에 접근한다. 웹서버에서 접근한 사용자에게 코드를 전달한다. 사용자 시스템 (웹 브라우져)에서 XSS 코드를 실행한다. 공격 성공!! 생각해보면, 간단하다. XSS 방어조치가 되어있지 않은 웹 서버에 스크립트를 저장하고, 다른 피해자들이 그 스크립트를 접근하는 그런 원리다. 결국 다른 피해자들은 브라우져를 통해 접근할테니, 스크립트를 온전히 읽어버리는 것이다. 방어조치가장 심플하게, 저장되는 글에 부등식기호(&lt;, &gt;)를 &lt; &gt; 등으로 Replace하여 저장하는 방법이 있다. 혹은 가 포함된 글은 무시한다던지.. 12description = description.replace('&lt;', '&amp;lt;')description = description.replace('&gt;', '&amp;gt;') 실습 웹 서버를 준비한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/local/bin/python3print(\"Content-Type: text/html\")print()import cgi, os, view form = cgi.FieldStorage()if 'id' in form: pageId = form[\"id\"].value description = open('data/'+pageId, 'r').read() update_link = '&lt;a href=\"update.py?id=&#123;&#125;\"&gt;update&lt;/a&gt;'.format(pageId) delete_action = ''' &lt;form action=\"process_delete.py\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"pageId\" value=\"&#123;&#125;\"&gt; &lt;input type=\"submit\" value=\"delete\"&gt; &lt;/form&gt; '''.format(pageId)else: pageId = 'Welcome' description = 'Hello, web' update_link = '' delete_action = ''print('''&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;WEB1 - Welcome&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;&lt;a href=\"index.py\"&gt;WEB&lt;/a&gt;&lt;/h1&gt; &lt;ol&gt; &#123;listStr&#125; &lt;/ol&gt; &lt;a href=\"create.py\"&gt;create&lt;/a&gt; &#123;update_link&#125; &#123;delete_action&#125; &lt;h2&gt;&#123;title&#125;&lt;/h2&gt; &lt;p&gt;&#123;desc&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'''.format( title=pageId, desc=description, listStr=view.getList(), update_link=update_link, delete_action=delete_action)) 웹 페이지에서 스크립트를 입력한다. 결과 확인. references https://opentutorials.org/course/3256/19935 https://terms.naver.com/entry.nhn?docId=3431916&amp;cid=58437&amp;categoryId=58437","categories":[],"tags":[]},{"title":"Python/venv","slug":"Python/venv","date":"2020-05-05T14:53:48.261Z","updated":"2020-05-05T14:53:48.261Z","comments":true,"path":"2020/05/05/Python/venv/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/Python/venv/","excerpt":"","text":"가상환경이란?프로젝트를 진행하다보면 외부 패키지의 버전관리와 디펜던시 관리는 필수적으로 진행되어야 한다. 파이썬에서는 디펜던시 관리를 가상환경으로 관리를 하고 있다. 설정python에서 제공되는 기능으로 간단히 설정할 수 있다. 아래처럼 하면 가상환경 폴더가 생성된다. 123[root@s16786679aff testProject]# python3 -m venv venv[root@s16786679aff testProject]# lsvenv 활성화설정이 되었다면 아래와 같이 활성화를 해준다. (venv)가 보이면 성공. 12[root@s16786679aff testProject]# source venv&#x2F;bin&#x2F;activate(venv) [root@s16786679aff testProject]# 패키지 설치해보기Flask를 설치하고 실행해보자. 123(venv) [root@s16786679aff testProject]#pip3 install flask(중략)Successfully installed Jinja2-2.10 MarkupSafe-1.1.1 Werkzeug-0.14.1 click-7.0 flask-1.0.2 itsdangerous-1.1.0 소스 작성 123456789from flask import Flaskapp = Flask(__name__)@app.route('/')def hello_world(): return 'Hello World!'if __name__ == '__main__': app.run() 동작 확인 1234567(venv) [root@s16786679aff testProject]# python3 app.py * Serving Flask app &quot;app&quot; (lazy loading) * Environment: production WARNING: Do not use the development server in a production environment. Use a production WSGI server instead. * Debug mode: off * Running on http:&#x2F;&#x2F;127.0.0.1:5000&#x2F; (Press CTRL+C to quit) 가상환경 종료아래와 같이 가상환경을 빠져나올 수 있다. 12(venv) [root@s16786679aff testProject]# deactivate[root@s16786679aff testProject]# 디펜던시 관리하기 requirements.txt아래와 같이 입력하면 requirements.txt 파일이 생성된걸 볼 수 있다. 123[root@s16786679aff testProject]# pip freeze &gt; requirements.txt[root@s16786679aff testProject]# lsapp.py requirements.txt venv vi requirements.txt 로 열어보면 현재 관리되고 있는 디펜던시를 확인할 수 있다. 123456789101112131415 1 bottle&#x3D;&#x3D;0.12.16 2 Click&#x3D;&#x3D;7.0 3 docutils&#x3D;&#x3D;0.14 4 EasyProcess&#x3D;&#x3D;0.2.3 5 Flask&#x3D;&#x3D;1.0.2 6 itsdangerous&#x3D;&#x3D;1.1.0 7 Jinja2&#x3D;&#x3D;2.10 8 lockfile&#x3D;&#x3D;0.12.2 9 MarkupSafe&#x3D;&#x3D;1.1.010 pidlockfile&#x3D;&#x3D;0.311 python-daemon&#x3D;&#x3D;2.2.012 PyVirtualDisplay&#x3D;&#x3D;0.2.113 selenium&#x3D;&#x3D;3.141.014 urllib3&#x3D;&#x3D;1.24.115 Werkzeug&#x3D;&#x3D;0.14.1 새로운 패키지를 추가하고 pip install -r requirements.txt를 통해 패키지를 관리할 수 있다.","categories":[],"tags":[]},{"title":"ML/Tensorflow object detection","slug":"ML/Tensorflow object detection","date":"2020-05-05T14:53:48.260Z","updated":"2020-05-05T15:17:19.482Z","comments":true,"path":"2020/05/05/ML/Tensorflow object detection/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/ML/Tensorflow%20object%20detection/","excerpt":"","text":"ML 입문, Tensorflow Object Detection API 호출하는 코드 만들기잘게 조각나 있는 정보들을 한 자리에 정리해보는 포스팅 용어 정리 텐서플로우 : 텐서플로우는 수치 계산과 대규모 머신러닝을 위한 오픈소스 라이브러리다. 머신러닝 : 기계 학습 또는 머신 러닝(영어: machine learning)은 인공 지능의 한 분야로, 컴퓨터가 학습할 수 있도록 하는 알고리즘과 기술을 개발하는 분야를 말한다. 가령, 기계 학습을 통해서 수신한 이메일이 스팸인지 아닌지를 구분할 수 있도록 훈련할 수 있다. 기계 학습의 핵심은 표현(representation)과 일반화(generalization)에 있다. 표현이란 데이터의 평가이며, 일반화란 아직 알 수 없는 데이터에 대한 처리이다. 이는 전산 학습 이론 분야이기도 하다. 다양한 기계 학습의 응용이 존재한다. 문자 인식은 이를 이용한 가장 잘 알려진 사례이다. 딥러닝 : 기계학습 알고리즘의 집합, 큰 틀에서 사람의 사고방식을 컴퓨터에 가르치는 기계학습의 한 분야 인공신경망 : 기계학습과 인지과학에서 생물학의 신경망(동물의 중추신경계중 특히 뇌)에서 영감을 얻은 통계학적 학습 알고리즘이다. 인공신경망은 시냅스의 결합으로 네트워크를 형성한 인공 뉴런(노드)이 학습을 통해 시냅스의 결합 세기를 변화시켜, 문제 해결 능력을 가지는 모델 전반을 가리킨다. 좁은 의미에서는 오차역전파법을 이용한 다층 퍼셉트론을 가리키는 경우도 있지만, 이것은 잘못된 용법으로, 인공신경망은 이에 국한되지 않는다. SSD : Pre-trained 모델, Single Shot MultiBox Detector Jupyter Notebook : 웹 브라우저에서 파이썬 코드를 작성하고 실행까지 해볼 수 있다고 함 아나콘다 : 파이썬 배포판 중 하나. 데이터 분석에 용이함. https://wikidocs.net/2825 여기서 32bit를 받으라고하는데, 왜??? 32비트용 애드온이 더 많은가? COCO API : COCO is a large image dataset designed for object detection, segmentation, person keypoints detection, stuff segmentation, and caption generation Tensorflow란?머신러닝은 복잡한 분야다. 그러나 구글 텐서플로우(TensorFlow)와 같은 머신러닝 프레임워크 덕분에 머신러닝 모델을 구현하는 과정은 예전만큼 복잡하거나 어렵지는 않다. 머신러닝 프레임워크는 데이터 획득, 모델 학습, 예측, 미래 결과 정제와 같은 과정을 쉽게 해준다. 텐서플로우는 수치 계산과 대규모 머신러닝을 위한 오픈소스 라이브러리다. 크게 머신러닝과 딥 러닝에 쓰인다. 그러나 실제 계산 작업은 파이썬으로 수행되지 않는다. 텐서플로우를 통해 제공되는 변환 라이브러리는 고성능 C++ 바이너리로 작성된다. 파이썬은 각 조각 사이의 트래픽에 길을 안내하고 이를 연결하기 위한 고차원적 프로그래밍 추상화를 제공할 뿐이다. 텐서플로우는 필기 숫자 판별, 이미지 인식, 단어 임베딩, 반복 신경망, 기계 번역을 위한 시퀀스 투 시퀀스 모델, 자연어 처리, PDE(편미분방정식) 기반 시뮬레이션 등을 위한 신경망을 학습, 실행할 수 있다. 무엇보다 좋은 점은 학습에 사용되는 것과 동일한 모델로 대규모 프로덕션 예측을 지원한다는 것이다. 텐서플로우와 경쟁 프레임워크 비교텐서플로우는 여러 머신러닝 프레임워크와 경쟁한다. 파이토치(PyTorch), CNTK, MXNet은 텐서플로우와 상당 부분 용도가 비슷한 주요 경쟁 프레임워크다. 필자가 생각한 텐서플로우와 비교한 각 프레임워크의 장단점은 다음과 같다. 파이토치(PyTorch): 파이썬으로 구축된다는 점 외에도 텐서플로우와 유사한 부분이 많다. 하드웨어 가속 구성 요소, 진행하면서 설계가 가능한 고도의 대화형 개발 모델, 그 외의 많은 유용한 구성 요소가 기본적으로 포함된다. 파이토치는 일반적으로 단시간 내에 실행해야 하는 빠른 프로젝트 개발에 더 유리하지만 큰 프로젝트와 복잡한 워크플로에서는 텐서플로우가 더 적합하다. CNTK: 마이크로소프트 코그니티브 툴킷(Cognitive Toolkit)은 텐서플로우와 마찬가지로 그래프 구조를 사용해 데이터 흐름을 기술하지만 딥 러닝 신경망을 만드는 데 초점을 둔다. CNTK는 여러 가지 신경망 작업을 더 빠르게 처리하며 폭넓은 API를 보유하고 있다(파이썬, C++, C#, 자바). 그러나 현재 CNTK는 텐서플로우만큼 배우고 배포하기가 쉽지는 않다. 아파치(Apache) MXNet: 아마존이 AWS의 고급 딥 러닝 프레임워크로 채택했으며 복수의 GPU와 머신에 걸쳐 거의 선형적으로 확장이 가능하다. 또한 파이썬, C++, 스칼라, R, 자바스크립트, 줄리아, 펄, 고 등 폭넓은 언어 API를 지원한다. 다만 네이티브 API의 사용편의성은 텐서플로우에 비해 떨어진다. editor@itworld.co.kr","categories":[],"tags":[]},{"title":"Linux/makingFTP","slug":"Linux/makingFTP","date":"2020-05-05T14:53:48.258Z","updated":"2020-05-05T14:53:48.258Z","comments":true,"path":"2020/05/05/Linux/makingFTP/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/Linux/makingFTP/","excerpt":"","text":"자바 NIO 기반 Http Server 만들기 NIO SocketChannel 생성 1234ServerSocketChannel serverSocketChannel = null;serverSocketChannel = ServerSocketChannel.open();serverSocketChannel.configureBlocking(true);serverSocketChannel.bind(new InetSocketAddress(PORT)); Wait 123SocketChannel socketChannel &#x3D; serverSocketChannel.accept();InetSocketAddress isa &#x3D; (InetSocketAddress) socketChannel.getRemoteAddress();System.out.println(isa.getHostName()); Read 123456789ByteBuffer buffer &#x3D; ByteBuffer.allocate(4096);int byteCount &#x3D; socketChannel.read(buffer);System.out.println(byteCount);buffer.flip();Charset charset &#x3D; Charset.forName(&quot;UTF-8&quot;);String data &#x3D; charset.decode(buffer).toString();System.out.println(data); Write 테스트 용도이기에 HTTP Header를 하드코딩으로 넣어주었다. 1234567891011121314byte[] data2 &#x3D; &quot;ok&quot;.getBytes();String content &#x3D; &quot;HTTP&#x2F;1.1 200 OK\\n&quot; + &quot;Server: Java HTTP NIO Server from hhcompany : 1.0\\n&quot; + &quot;Date: &quot; + new Date()+ &quot;Content-type: &quot; +&quot;text&#x2F;plain&quot; + &quot;\\n&quot;+ &quot;Content-length: &quot; + data2.length +&quot;\\n&quot;+ &quot;\\n&quot;;content+&#x3D; &quot;ok&quot;;ByteBuffer byteBuffer &#x3D; null;byteBuffer &#x3D; charset.encode(content);socketChannel.write(byteBuffer); Close1234567if (serverSocketChannel !&#x3D; null &amp;&amp; serverSocketChannel.isOpen()) &#123; try &#123; serverSocketChannel.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125;&#125;","categories":[],"tags":[]},{"title":"HTTP/The_basic_of_web","slug":"HTTP/The_basic_of_web","date":"2020-05-05T14:53:48.257Z","updated":"2020-05-05T14:53:48.258Z","comments":true,"path":"2020/05/05/HTTP/The_basic_of_web/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/HTTP/The_basic_of_web/","excerpt":"","text":"HTTP : 웹의 기초Http 프로토콜을 빠르게 훑어본다. HTTP? 전세계의 웹 브라우저, 서버, 웹 애플리케이션은 모두 HTTP를 통해 서로 대화한다. HTTP는 TCP를 사용하기 때문에, 데이터 손실이 없음을 보장한다. 리소스 웹서버는 웹 리소스를 관리하고 제공한다. 가장 단순한 웹 리소스는 웹 서버 파일 시스템의 정적 파일이다. 정적 파일은 텍스트, HTML, WORD등 모든 종류의 파일을 의미한다. 그러나 꼭 모든 파일이 정적일 필요는 없으며, 리소스 요청에 따라 동적 콘텐츠를 제공하기도 한다. 웹캠으로부터 받아오는 리소스, 주식거래 리소스 등 서버 외부로부터 받아올 수 있다. 미디어 타입 인터넷은 순천 가지 데이터 타입을 다루기 때문에, HTTP는 웹에서 전송되는 객체 각자에 MIME타입이라는 포맷 라벨을 이용한다. MIME은 사선으로 구분된 주 타입과 부 타입으로 문자열 라벨이다. text/html text/plain image/jpeg image/gif URI (uniform resource identifier) 웹 서버 리소스는 각자 이름을 갖고 있기 때문에, 클라이언트는 리소스를 지목할 수 있다. URI에는 두가지가 있는데, URL과 URN이라는 거다. URL uniform resource locator는 리소스 식별자의 가장 흔한 형태이다. 서버의 특정 한 리소스에 대해 구체적인 위치를 서술한다.http://www.oreilly.com/index.html 대부분의 URL은 세 부분으로 이루어진 표준 포맷을 따른다. 프로토콜 : scheme (http://) 인터넷 주소 : www.joes-hardware.com 리소스 : /specials/saw-blade.gif URN uniform resource name은 콘텐츠를 이루는 한 리소스에 대해, 그 리소스의 위치에 영향 받지 않는 유일무이한 이름 역할을 한다. 위치 독립적이기때문에, 여기저기로 리소를 옮기더라도 정상적으로 동작한다. ex) 인터넷 표준문서 RFC 2141이 어디에 있거나 상관없이 그것을 지칭하기 위해 사용한다.urn:ietf:rfc:2141 URN아직 실험단계이며 널리 채택되지 않았다. 트랙잭션 HTTP 트랜잭션은 요청과 응답으로 이루어져있다.요청의 예GET /specials/saw-blade.gif HTTP/1.0 시작줄Host: www.joes-hardware.com 헤더 시작Accept: text/*Accept-Language: en,fr 헤더 끝 응답의 예HTTP/1.0 200 OK 시작줄Content-type: image/gif 헤더 시작Content-length: 8572 헤더 끝본문 메서드 흔히 쓰이는 HTTP 메서드 GET 서버에서 클라이언트로 지정한 리소스를 보내라. PUT 클라이언트에서 서버로 보낸 데이터를 지정한 이름의 리소스로 저장하라. DELETE 지정한 리소스를 서버에서 삭제하라. POST 클라이언트 데이터를 서버 게이트웨이 애플리케이션으로 보내라. HEAD 지정한 리소스에 대한 응답에서, HTTP 헤더 부분만 보내라. 상태코드 모든 응답 메세지는 상태 코드와 함께 반환된다. 200 좋다. 302 다시보내라. 404 없다. 메세지 메세지는 크게 세 가지로 나뉘어진다. 시작줄 요청과 응답의 상태를 나타낸다. 헤더 시작줄 다음에 0개 이상의 헤더 필드가 이어진다. 각 헤더 필드는 쉬운 구문분석을 위해 콜론(:)으로 구분되어 하나의 이름과 하나의 값으로 구성된다. 헤더는 빈 줄로 끝난다. 본문 빈줄 다음부터 본문의 내용이 시작된다. TCP/IP HTTP는 애플리케이션 레이어의 프로토콜이며, HTTP또한 메세지들을 전송하기 위하여 TCP/IP의 프로토콜을 이용하는 것뿐이다. 웹 브라우저는 서버의 URL에서 호스트 명을 추출한다. 웹 브라우저는 서버의 호스트 명을 IP로 변환한다. 웹 브라우저는 URL에서 포스번호를 추출한다. 웹 브라우저는 웹 서버와 TCP 커넥션을 맺는다. 웹 브라우저는 서버에 HTTP 요청을 보낸다. 서버는 웹 브라우저에 HTTP 응답을 돌려준다. 커넥션이 닫히면, 웹 브라우저는 문서를 보여준다.","categories":[],"tags":[]},{"title":"HTTP/그런 REST API로 괜찮은가?","slug":"HTTP/그런 REST API로 괜찮은가?","date":"2020-05-05T14:53:48.257Z","updated":"2020-05-05T14:53:48.257Z","comments":true,"path":"2020/05/05/HTTP/그런 REST API로 괜찮은가?/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/HTTP/%E1%84%80%E1%85%B3%E1%84%85%E1%85%A5%E1%86%AB%20REST%20API%E1%84%85%E1%85%A9%20%E1%84%80%E1%85%AB%E1%86%AB%E1%84%8E%E1%85%A1%E1%86%AD%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%80%E1%85%A1?/","excerpt":"","text":"그런 REST API로 괜찮은가? DEVIEW 2017 2-2 SECTION 그런 REST API로 괜찮은가 영상을 보고나서 작성 하는 글이다. 영상을 본 뒤 전 회사에서 작성했던 REST API를 돌이켜 생각해보니 이런 REST API로는 괜찮지 않았다. 당시에도 REST API 설계에 관심이 많았으나, 내가 작성했던 것들은 무언가 하나씩 잘못되어있었다. 영상에선 Roy T. Felding의 직접적인 의견들을 토대로 World wide web 부터 현재의 Rest API까지 이르기까지를 설명하고 있다. Web (1991) Q. 어떻게 인터넷에서 정보를 공유할 것인가? A. 정보들을 하이퍼텍스트로 연결한다. 1) 표현형식 : HTML 2) 식별자 : URI 3) 전송방법 : HTTP Roy T. Fielding Says “How do I improve HTTP without breaking the Web?” “Rest APIs must be hypertext-driven” “REST API를 위한 최고의 버저닝 전략은 버저닝을 안 하는 것” REST APIREST API는 분산 하이퍼미디어 시스템을 위한 아키텍쳐 스타일이다. 아키텍쳐 스타일은 제약조건의 집합인데, 이 말은 즉 제약조건을 모두 지켜야 REST API라고 말을 할 수 있다는 것이다. 다음은 REST API의 제약조건들 이다. client-server stateless cache uniform interface layered system code-on-demand (optional)서버에서 코드를 client로 보내어 바로 실행할 수 있어야한다 uniform interface 을 잘 만족 시켜야 REST 하다. 라고할 수있다. identification of resource리소스가 URI가 식별되어야한다. manipulation of resources through representations리소스를 만들거나 삭제하거나할 때 HTTP 메세지에 표현을 담아야 한다. self-descriptive messages메세지는 스스로에 설명할 수 있어야 한다. 다음은 강연자가 설명하는 self-descriptive messages의 예시이다. Response Message에서 HTTP의 상태 설명과 body의 media type을 충분히 설명하고 있어 self-descriptive 하다고 하는 것이다. hypermedia as the engine of application sate어플리케이션의 상태는 hyperlink를 통해서 항상 전이가 되어야한다.","categories":[],"tags":[]},{"title":"Flutter/firebase_messaging","slug":"Flutter/firebase_messaging","date":"2020-05-05T14:53:48.255Z","updated":"2020-05-05T14:53:48.255Z","comments":true,"path":"2020/05/05/Flutter/firebase_messaging/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/Flutter/firebase_messaging/","excerpt":"","text":"123&lt;application android:name=\".Application\" android:icon=\"@mipmap/ic_launcher\"&gt; 1234567891011121314151617181920package ga.clecture.c_lecture;import io.flutter.app.FlutterApplication;import io.flutter.plugin.common.PluginRegistry;import io.flutter.plugin.common.PluginRegistry.PluginRegistrantCallback;import io.flutter.plugins.firebasemessaging.FlutterFirebaseMessagingService;public class Application extends FlutterApplication implements PluginRegistrantCallback &#123; @Override public void onCreate() &#123; super.onCreate(); FlutterFirebaseMessagingService.setPluginRegistrant(this); &#125; @Override public void registerWith(PluginRegistry registry) &#123; FirebaseCloudMessagingPluginRegistrant.registerWith(registry); &#125;&#125; 1234567891011121314151617181920212223package ga.clecture.c_lecture;import io.flutter.plugin.common.PluginRegistry;import io.flutter.plugins.firebasemessaging.FirebaseMessagingPlugin;public final class FirebaseCloudMessagingPluginRegistrant &#123; public static void registerWith(PluginRegistry registry) &#123; if (alreadyRegisteredWith(registry)) &#123; return; &#125; FirebaseMessagingPlugin.registerWith(registry.registrarFor(\"io.flutter.plugins.firebasemessaging.FirebaseMessagingPlugin\")); &#125; private static boolean alreadyRegisteredWith(PluginRegistry registry) &#123; final String key = FirebaseCloudMessagingPluginRegistrant.class.getCanonicalName(); if (registry.hasPlugin(key)) &#123; return true; &#125; registry.registrarFor(key); return false; &#125;&#125; FCM 2번 먹는 이슈 12345class MainActivity: FlutterActivity() &#123; &#x2F;* override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) &#123; GeneratedPluginRegistrant.registerWith(flutterEngine); &#125;*&#x2F;&#125;","categories":[],"tags":[]},{"title":"HTTP/Java NIO Http Server","slug":"HTTP/Java NIO Http Server","date":"2020-05-05T14:53:48.255Z","updated":"2020-05-05T14:53:48.255Z","comments":true,"path":"2020/05/05/HTTP/Java NIO Http Server/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/HTTP/Java%20NIO%20Http%20Server/","excerpt":"","text":"NIO 기반 Http Server Lib를 만들어보자. 테스트코드 작성 127.0.0.1:8080에 접속했을 때 ok가 뜨도록 테스트 코드를 작성하자. 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class NIOHttpServerTest&#123; private NIOHttpServer nioHttpServer = null; @Before public void setUp()&#123; nioHttpServer = new NIOHttpServer(8080); nioHttpServer.start(); &#125; @Test public void localhost_접근시_http_response가_있어야함()&#123; try &#123; URL url = new URL(\"http://localhost:8080\"); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); System.out.println(\"Response code: \" + conn.getResponseCode()); Assert.assertTrue(conn.getResponseCode() == 200); BufferedReader rd; if(conn.getResponseCode() &gt;= 200 &amp;&amp; conn.getResponseCode() &lt;= 300) &#123; rd = new BufferedReader(new InputStreamReader(conn.getInputStream())); &#125; else &#123; rd = new BufferedReader(new InputStreamReader(conn.getErrorStream())); &#125; StringBuilder sb = new StringBuilder(); String line; while ((line = rd.readLine()) != null) &#123; sb.append(line); &#125; rd.close(); conn.disconnect(); System.out.println(sb.toString()); &#125; catch (Exception e)&#123; System.out.println(e); &#125; &#125; @After public void dispose()&#123; nioHttpServer.stop(); &#125;&#125; 서버 생성 NIO SocketChannel 생성 1234ServerSocketChannel serverSocketChannel = null;serverSocketChannel = ServerSocketChannel.open();serverSocketChannel.configureBlocking(true);serverSocketChannel.bind(new InetSocketAddress(PORT)); Wait 123SocketChannel socketChannel = serverSocketChannel.accept();InetSocketAddress isa = (InetSocketAddress) socketChannel.getRemoteAddress();System.out.println(isa.getHostName()); Read 123456789ByteBuffer buffer = ByteBuffer.allocate(4096);int byteCount = socketChannel.read(buffer);System.out.println(byteCount);buffer.flip();Charset charset = Charset.forName(\"UTF-8\");String data = charset.decode(buffer).toString();System.out.println(data); Write 테스트 용도이기에 HTTP Header를 하드코딩으로 넣어주었다. 1234567891011121314byte[] data2 = \"ok\".getBytes();String content = \"HTTP/1.1 200 OK\\n\" + \"Server: Java HTTP NIO Server from hhcompany : 1.0\\n\" + \"Date: \" + new Date()+ \"Content-type: \" +\"text/plain\" + \"\\n\"+ \"Content-length: \" + data2.length +\"\\n\"+ \"\\n\";content+= \"ok\";ByteBuffer byteBuffer = null;byteBuffer = charset.encode(content);socketChannel.write(byteBuffer); Close1234567if (serverSocketChannel != null &amp;&amp; serverSocketChannel.isOpen()) &#123; try &#123; serverSocketChannel.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125;&#125;","categories":[],"tags":[]},{"title":"CSS/mediaquery","slug":"CSS/mediaquery","date":"2020-05-05T14:53:48.252Z","updated":"2020-05-05T14:53:48.252Z","comments":true,"path":"2020/05/05/CSS/mediaquery/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/CSS/mediaquery/","excerpt":"","text":"미디어 쿼리미디어 쿼리 기능을 이용해서 반응형 웹 디자인을 할 수 있다. 문법 은 다음과 같다.1234567@media (max-width:800px) &#123; selectors&#125;@media (min-width:800px) &#123; selectors&#125; 문법은 상당히 간단지만, 문제점이 몇 가지 보인다. 우선, CSS코드 양이 약 2배 가량 늘어난다. 가로모드, 세로모드 css 파일을 분리해야하는건가? 문법이 한번에 읽히지 않는다…. 비교 연산자가 필요해 ㅜㅜ 다음은 작업중인 포트폴리오 페이지를 미디어쿼리 입힌 모습이다. 가로버전 세로버전 소스123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;WEB - CSS&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt; &lt;style&gt; body &#123; margin: 0; &#125; a &#123; color: black; text-decoration: none; &#125; h1 &#123; font-size: 45px; text-align: center; border-bottom: 1px solid gray; margin: 0; padding: 20px; &#125; #grid #article &#123; padding-left: 25px; &#125; /*세로모드*/ @media (max-width:800px) &#123; #grid &#123; display: grid; grid-template-rows: auto; &#125; #grid #nav &#123; text-align: center; &#125; #grid #nav ol li &#123; display: inline; &#125; &#125; /*가로모드*/ @media (min-width:800px) &#123; #grid &#123; display: grid; border: solid; padding:20px; grid-template-columns: 150px 1fr; &#125; #grid #nav &#123; border-right: 1px solid gray; &#125; #grid #nav ol &#123; padding-left: 33px; width: 100px; margin: 0; padding: 20px; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;&lt;a href=\"index.html\"&gt;Portfolio&lt;/a&gt;&lt;/h1&gt; &lt;div id=\"grid\"&gt; &lt;div id=\"nav\"&gt; &lt;ol&gt; &lt;li&gt;&lt;a href=\"1.html\"&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"2.html\"&gt;Portfolio&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"3.html\"&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; &lt;div id=\"article\"&gt; &lt;h2&gt;조환희&lt;/h2&gt; &lt;p&gt; Cascading Style Sheets (CSS) is a style sheet language used for describing the presentation of a document written in a markup language.[1] Although most often used to set the visual style of web pages and user interfaces written in HTML and XHTML, the language can be applied to any XML document, including plain XML, SVG and XUL, and is applicable to rendering in speech, or on other media. Along with HTML and JavaScript, CSS is a cornerstone technology used by most websites to create visually engaging webpages, user interfaces for web applications, and user interfaces for many mobile applications. &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"CSS/grid","slug":"CSS/grid","date":"2020-05-05T14:53:48.251Z","updated":"2020-05-05T14:53:48.251Z","comments":true,"path":"2020/05/05/CSS/grid/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/CSS/grid/","excerpt":"","text":"GridCSS레이아웃 구성 방법 중 가장 최근에 나온 기술로 그리드 형태의 레이아웃 구성에 유리하다. Point Property를 다음과 같이 준다. display:grid; grid-template-columns: 150px 1fr; ETC div, span은 모두 레이아웃을 위한 태그인데 div는 block level이고 span은 inline level이다. Source12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" dir=\"ltr\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #grid &#123; border:5px solid pink; display:grid; /*nfr : weight 라고 생각하면 됨*/ grid-template-columns: 150px 1fr; &#125; div &#123; border:5px solid gray; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"grid\"&gt; &lt;div&gt;NAVIGATION&lt;/div&gt; &lt;div&gt;askdfjksadjfkls adjfklasdjfkasdjfkasdjkfsd jkfjsadkfjkasldfjklasdaskdf jksadjfklsadjfklasdjfkasdjfka sdjkfsdjkfjsadkfjkasldfjk &lt;/div&gt; &lt;/div&gt;&lt;!-- display : inline &lt;span&gt;NAVIGATION&lt;span&gt; &lt;span&gt;ARTICLE&lt;span&gt; --&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"CSS/README","slug":"CSS/README","date":"2020-05-05T14:53:48.250Z","updated":"2020-05-05T14:53:48.250Z","comments":true,"path":"2020/05/05/CSS/README/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/CSS/README/","excerpt":"","text":"CSS 학습 내용CSS는 html에서 기능적 요소와 디자인적 요소를 분리하고자 개발된 언어이다. 만약 다음과 같은 코드에서 a태그 글자의 색상을 변경하고자 한다면.123456&lt;h1&gt;&lt;a href=\"index.html\"&gt;WEB&lt;/a&gt;&lt;/h1&gt;&lt;ol&gt; &lt;li&gt;&lt;a href=\"1.html\"&gt;HTML&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"2.html\"&gt;CSS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"3.html\"&gt;JavaScript&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt; 이와 같이 html에서 문서의 구조가 아닌, 디자인적 기능을 하는 태그를 이용해야만된다. (태그)123456&lt;h1&gt;&lt;a href=\"index.html\"&gt;&lt;font color=\"red\"&gt;WEB&lt;/font&gt;&lt;/a&gt;&lt;/h1&gt;&lt;ol&gt; &lt;li&gt;&lt;a href=\"1.html\"&gt;&lt;font color=\"red\"&gt;HTML&lt;/font&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"2.html\"&gt;&lt;font color=\"red\"&gt;CSS&lt;/font&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"3.html\"&gt;&lt;font color=\"red\"&gt;JavaScript&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt; 이럴때 html에서 디자인적 기능을 분리하는 CSS를 이용하면, html은 문서의 구조만을 나타내게 되고 코드의 가독성은 훨씬 올라갈 수 있다.123456789101112131415161718192021222324252627282930&lt;head&gt; &lt;title&gt;JoHwanhee&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;link rel=\"stylesheet\" href=\"css/uikit.min.css\" /&gt; &lt;script src=\"js/uikit.min.js\"&gt;&lt;/script&gt; &lt;script src=\"js/uikit-icons.min.js\"&gt;&lt;/script&gt; &lt;style&gt; a &#123; color: black; text-decoration: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body background=\"\"&gt; &lt;h1&gt;&lt;a href=\"index.html\"&gt;WEB&lt;/a&gt;&lt;/h1&gt; &lt;ol&gt; &lt;li&gt;&lt;a href=\"1.html\"&gt;HTML&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"2.html\"&gt;CSS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"3.html\"&gt;JavaScript&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;h2&gt;CSS&lt;/h2&gt; &lt;p&gt; Cascading Style Sheets (CSS) is a style sheet language used for describing the presentation of a document written in a markup language.[1] Although most often used to set the visual style of web pages and user interfaces written in HTML and XHTML, the language can be applied to any XML document, including plain XML, SVG and XUL, and is applicable to rendering in speech, or on other media. Along with HTML and JavaScript, CSS is a cornerstone technology used by most websites to create visually engaging webpages, user interfaces for web applications, and user interfaces for many mobile applications. &lt;/p&gt;&lt;/body&gt;","categories":[],"tags":[]},{"title":"CSS/Selector","slug":"CSS/Selector","date":"2020-05-05T14:53:48.250Z","updated":"2020-05-05T14:53:48.250Z","comments":true,"path":"2020/05/05/CSS/Selector/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/CSS/Selector/","excerpt":"","text":"SelectorCSS 선택자를 스스로 알아내는 방법 ID는 한번만 등장하는것이 좋다. 우선순위는 구체적일수록 높다. 우선순위가 같으면 더 나중에 등장한 Selector가 적용된다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;JoHwanhee&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;link rel=\"stylesheet\" href=\"css/uikit.min.css\" /&gt; &lt;script src=\"js/uikit.min.js\"&gt;&lt;/script&gt; &lt;script src=\"js/uikit-icons.min.js\"&gt;&lt;/script&gt; &lt;style&gt; /*좀 더 구체적인것이 우선순위가 더 높음*/ /*id 선택자가 가장 우선순위 높음 : id는 단 한번만 등장하기 때문에! */ #active &#123; color : red; &#125; /*class는 그 다음*/ .saw &#123; color : gray; &#125; /*마지막은 태그 선택자*/ a &#123; color: black; text-decoration: none; &#125; h1 &#123; font-size: 60px; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body background=\"\"&gt; &lt;h1&gt;&lt;a href=\"index.html\"&gt;WEB&lt;/a&gt;&lt;/h1&gt; &lt;ol&gt; &lt;li&gt;&lt;a href=\"1.html\" class=\"saw\"&gt;HTML&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"2.html\" class=\"saw\" id=\"active\"&gt;CSS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"3.html\"&gt;JavaScript&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;h2&gt;CSS&lt;/h2&gt; &lt;p&gt; Cascading Style Sheets (CSS) is a style sheet language used for describing the presentation of a document written in a markup language.[1] Although most often used to set the visual style of web pages and user interfaces written in HTML and XHTML, the language can be applied to any XML document, including plain XML, SVG and XUL, and is applicable to rendering in speech, or on other media. Along with HTML and JavaScript, CSS is a cornerstone technology used by most websites to create visually engaging webpages, user interfaces for web applications, and user interfaces for many mobile applications. &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 추가정보 : https://www.w3schools.com/csSref/css_selectors.asp","categories":[],"tags":[]},{"title":"CSS/boxmodel","slug":"CSS/boxmodel","date":"2020-05-05T14:53:48.250Z","updated":"2020-05-05T14:53:48.251Z","comments":true,"path":"2020/05/05/CSS/boxmodel/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/CSS/boxmodel/","excerpt":"","text":"Box modelhtml 에서 태그 하나하나를 박스로 취급하여 부피감을 갖게 한다. 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" dir=\"ltr\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;box&lt;/title&gt; &lt;style &gt; /*block level element*/ /*h1 &#123; border-width:5px; border-color:red; border-style:solid; display:inline; &#125; inline level a &#123; border-width:5px; border-color:red; border-style:solid; display:block; &#125;*/ /*h1, a&#123; border:5px solid red; display:inline; &#125;*/ h1 &#123; border:5px solid red; padding:50px; margin:20; width:100px; display: inline; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;CSS&lt;/h1&gt; &lt;h1&gt;CSS&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"CS/compile","slug":"CS/compile","date":"2020-05-05T14:53:48.248Z","updated":"2020-05-05T14:53:48.248Z","comments":true,"path":"2020/05/05/CS/compile/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/CS/compile/","excerpt":"","text":"실행의 정의 실행이란? CPU가 알아 들을 수 있는 명령을 하는 것 사용자 명령 test.exe -&gt; 실행 이미지 로드 -&gt; (COPY) -&gt; 인스턴스(Process) 생성 RAM -&gt; 기계어 코드 실행 기계어를 가지고 있는 실행 파일을 하드디스크로부터 주기억장치로 복사한 후에 인스턴스로 만들고 관리할 수 있도록 체계를 부여한 후에 CPU가 하나씩 실행하는 것 CPU의 역할은 무엇인가? 연산!!! 기계어란 무엇인가? CPU 제조사 : intel, amd, arm intel, amd 프로세서는 x86 호환 프로세서다. CPU가 일을 하기 위해서 명령을 내려야 하는데, 이 명령어가 기계어다. 32bit platform 이란 무엇인가? 메인 메모리가 32bit의 주소체계로 이루어진 플랫폼 운영체제에 대해 알고 있는 것은 무엇인가? 프로그래밍 언어로 컴파일을 하면 기계어를 가지고 있는 실행파일을 만들 수 있다. CPU의 연산 CPU내부의 소량의 기억장치가 있고(레지스터) 그 것이 RAM의 정보를 읽어와서 연산을 하고 특정한 메모리에 저장한다. *0x0012FF7C = *0x0012FF70 + *0x0012FF74 : 0x0012FF70의 정보를 읽어와서 특정 레지스터에 저장하고, 0x0012FF74의 정보도 읽어와서 특정 레지스터에 저장해서 덧셈 연산(CPU)을 한 후에 0x0012FF7C에 대입하라. 결국 이건 메모리를 사용하는것이다. 연산은 CPU가 함!!!! 컴파일 과정 정리컴파일이란? 사람이 이해할 수 있는 언어로 된 프로그램 코드를 컴퓨터가 이해할 수 있는 언어로 변환 하는 작업. 여러 소스 파일을 컴파일해서 각 부품을 만들고 그 부품을 조립하여 하나의 실행 파일로 만든다. 여러 소스파일 (helloworld.h helloworld.c, test.c) 부품 (helloworld.obj, test.obj) 실행파일 (helloworld.exe) 컴파일 -&gt; 링크 -&gt; 실행파일 GCC 컴파일 과정 helloworld.c -&gt; helloworld.i -&gt; helloworld.s -&gt; helloworld.o -&gt; helloworld전처리 -&gt; 컴파일 -&gt; 어셈블링 -&gt; 링킹 전처리 과정 전처리 과정은 크게 두 부분으로 나뉘어짐 헤더파일 삽입 매크로 치환 및 적용 #define 부분을 심볼테이블에 저장 됨 실볼 테이블에 들어있는 문자열과 같은 문자열을 만나면 #define 된 내용으로 치환합니다. 컴파일 과정 전처리 과정이 끝나면 컴파일 과정이 시작된다. 크게 전단부, 중단부, 후단부로 나뉘어진다. 전처리가 끝난 .i 파일을 컴파일하면 .s 어셈블리 코드로 이루어진 파일이 만들어진다. 전단부 전단부에서는 언어 종속적인 부분을 처리한다. 이 단계에서는 C로 작성된코드나 다른 언어로 작성된 코드들이 각각 다른 모듈에 의해 처리 된다. 또한 소스코드가 올바르게 작성되었는지 분석하고, 중단부에 넘겨주기 위한 GIMPLE 트리를 생성하는 일을 수행한다. 중단부 중단부에서는 전단부에서 넘겨받은 GIMPLE 트리를 SSA(Static Single Assignment)형태로 변환한 후에 아키텍쳐 비종속적인 최적화를 수행한 후 최종적으로 후단부에서 사용하는 RTL(Register Transfer Language: 고급 언어와 어셈블리 언어의 중간 형태)을 생성합니다. 아키텍쳐 비종속적인 최적화란 서로 다른 CPU 아키텍쳐에 구애받지 않고 공통적으로 수행할 수 있는 최적화를 말합니다. 중단부에서는 SSA 기반으로 최적화를 수행합니다. 후단부 후단부에서는 RTL Optimizer에 의해 아키텍쳐 비종속적인 최적화와 함께 아키텍쳐 종속적인 최적화가 수행합니다. 이렇게 최적화를 마치게 되면 Code Generator 어셈블리어로 구성된 .s 파일이 만들어지게 됩니다. 어셈블 과정 어셈블러에 의해 생성되는 목적코드(helloworld.o) 파일은 어셈블된 프로그램의 명령어(Instruction)과 데이터(Data)가 들어있는 ELF 바이너리 포맷(Binary format) 구조를 갖습니다. 링킹 과정 어셈블리에 의해 ELF 포맷의 목적코드 파일들이 만들어지면 이제 링커가 나설 차례입니다. 링커는 오브젝트 파일들과 여러분의 프로그램에서 사용된 표준 C 라이브러리, 사용자 라이브러리들을 링크(Link)를 합니다. printf() 함수나 scanf() 등의 표준 C 라이브러리 함수들은 여러분이 직접 구현하지 않아도 미리 컴파일이 되어 있기 때문에 링크하는 과정만 거치면 사용할 수 있습니다. (표준 C 라이브러리는 별도로 명시하지 않아도 자동으로 링크됩니다) 이렇게 링킹 과정이 끝나면 드디어 실행 가능한 실행파일이 만들어지게 됩니다.","categories":[],"tags":[]},{"title":"Algorithm/climb","slug":"Algorithm/climb","date":"2020-05-05T14:53:48.247Z","updated":"2020-05-05T15:07:16.975Z","comments":true,"path":"2020/05/05/Algorithm/climb/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/Algorithm/climb/","excerpt":"","text":"12345678int climb(int n)&#123; if( n == 0 ) return 1; return climb(n - 1) + climb(n - 2) + climb(n - 3);&#125;printf(\"%d\", climb(5));","categories":[],"tags":[]},{"title":"Algorithm/insertSort","slug":"Algorithm/insertSort","date":"2020-05-05T14:53:48.247Z","updated":"2020-05-05T15:05:54.185Z","comments":true,"path":"2020/05/05/Algorithm/insertSort/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/Algorithm/insertSort/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;string.h&gt;void insertSort(int* arr, int left, int right) &#123; int value = 0; for (int i = left + 1; i &lt; right; i++) &#123; if(arr[i-1] &lt;= arr[i]) continue; value = arr[i]; for(int j = 0; j &lt; i; j++) &#123; if(arr[j] &gt; arr[i]) &#123; memmove(&amp;arr[j + 1], &amp;arr[j], sizeof (arr[0]) * (i - j)); arr[j] = value; break; &#125; &#125; &#125;&#125;int main() &#123; int arr[] = &#123; 5, 7, 89, 3, 2, 2, 2&#125;; int size = sizeof arr / sizeof arr[0]; insertSort(arr, 0, size); for (int i = 0; i &lt; size; i++) printf(\"%d \", arr[i]); return 0;&#125;","categories":[],"tags":[]},{"title":"Algorithm/hash","slug":"Algorithm/hash","date":"2020-05-05T14:53:48.247Z","updated":"2020-05-05T14:53:48.247Z","comments":true,"path":"2020/05/05/Algorithm/hash/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/Algorithm/hash/","excerpt":"","text":"hash table해시 테이블의 기본 개념 컴퓨터에서 표현되는 모든 데이터들은 결국 숫자이다.예를들어 우리가 알파벳 ‘a’를 화면에 표현하고자하면 컴퓨터는 내부적으로 49라는 숫자를 가지고 있고, 이 숫자가 화면에 표시할땐 ‘a’ 라고 표시하자! 라는 규칙이 있는 것이다. 해쉬 테이블은 이 개념을 가장 잘 이용한 자료구조이다. 해시테이블은 데이터들을 각 저장소 h = s[0]31^(n-1) + s[1]31^(n-2) …………..+s[n-1]; Additive and Multiple Hashing 이다. (출처 Knuth, ) a는 처음에는 크게 상관없다고 생각했으나, 기존 코드 및 인터넷 검색을 해보니 대체로, 소수 (특히 31)을 사용하고 있었다. 31을 사용하는 이유는 32 - 1, 즉 val을 bit-shift 5칸 한 것에서 val을 한번 빼주면 되어서, 컴터가 더 빠른 연산을 하나 보다.","categories":[],"tags":[]},{"title":"Algorithm/quickSort","slug":"Algorithm/quickSort","date":"2020-05-05T14:53:48.247Z","updated":"2020-05-05T15:06:52.234Z","comments":true,"path":"2020/05/05/Algorithm/quickSort/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/Algorithm/quickSort/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;void quickSort(int* arr, int left, int right) &#123; int i = left, j = right; int pivot = arr[(left + right) / 2]; int temp; do &#123; while (arr[i] &lt; pivot) i++; while (arr[j] &gt; pivot) j--; if (i &lt;= j) &#123; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; i++; j--; &#125; &#125; while (i &lt;= j); if (left &lt; j) quickSort(arr, left, j); if (i &lt; right) quickSort(arr, i, right);&#125;int main() &#123; int arr[] = &#123; 5, 7, 89, 3, 2, 2, 2&#125;; int size = sizeof arr / sizeof arr[0]; quickSort(arr, 0, size - 1); for (int i = 0; i &lt; size; i++) printf(\"%d \", arr[i]); return 0;&#125;","categories":[],"tags":[]},{"title":"C/object_type_variables","slug":"C/object_type_variables","date":"2020-05-05T14:53:48.247Z","updated":"2020-05-05T14:53:48.247Z","comments":true,"path":"2020/05/05/C/object_type_variables/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/C/object_type_variables/","excerpt":"","text":"오브젝트, 타입, 변수에 대하여 Object실행시에 표현할 수 있는 값들을 저장하는 곳을 Object라고 합니다.예를들어, printf(“%d” ,10) 이라고 할 경우에 10이라는 숫자는 한 어느 저장소에 들어있고 이 저장소를 Object라고 합니다. 타입타입은 큰 의미로 Object 타입과 function 타입으로 나뉘어집니다. 또 다시 Object 타입은 complete 타입과 imcomplete 타입으로 나뉘어지며complete 타입은 크기를 결정할 정보가 완전한 경우 입니다. ( basic types and pointer type )imcomptete 타입은 크기를 결정할 정보가 불완전한 경우 입니다. ( void, array of unkown size, structure, union, enum ) 변수변수 = Object + 식별자 References http://www.msg.ucsf.edu/local/programs/IBM_Compilers/C:C++/html/language/ref/clrc03incotyp.htm","categories":[],"tags":[]},{"title":"C/pointer","slug":"C/pointer","date":"2020-05-05T14:53:48.247Z","updated":"2020-05-05T14:53:48.247Z","comments":true,"path":"2020/05/05/C/pointer/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/C/pointer/","excerpt":"","text":"여러 포인터 종류들포인터 배열원소가 포인터인 배열, 주로 여러줄의 문자열을 나타낼때 쓴다. 1234567char *arps[] = &#123; \"고양이\",\"개\",\"오랑우탄\",\"돼지\",\"지렁이\" &#125;;int i;for (i = 0; i &lt; 5; i++) &#123; printf(\"%s\\n\", arps[i]);&#125; 배열 포인터단순히 배열의 번지수를 담는 포인터, 주로 2중 배열 인자로 받기 위해 쓴다.. 12345678910int arr[5][4] =&#123; &#123;1,2,3,4&#125;, &#123;5,6,7,8&#125;, &#123;9,10,11,12&#125;&#125;;int (*ptr)[4] = (int (*)[4])malloc(sizeof(int) * 5 * 4);ptr[1][2] = 1;printf(\"%d\\n\", ptr[1][2]); 2중포인터포인터의 포인터! 12345678int **ppArr = (int **)malloc(sizeof(int *) * 5);for(int i = 0; i &lt; 5; i++)&#123; ppArr[i] = (int *)malloc(sizeof(int) * 4);&#125;ppArr[1][2] = 10;printf(\"%d\\n\", ppArr[1][2]);","categories":[],"tags":[]},{"title":"CS/Windows","slug":"CS/Windows","date":"2020-05-05T14:53:48.247Z","updated":"2020-05-05T14:53:48.247Z","comments":true,"path":"2020/05/05/CS/Windows/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/CS/Windows/","excerpt":"","text":"컴퓨터는 CPU + RAM + 버스 CPU에는 ALU, CU, REGISTERS가 있음 ALU는 계산장치고 CU는 CPU의 동작을 관할함 레지스터는 CPU가 연산할때 뭐 주소를 저장하거나 데이터를 저장하거나 등등 임시 저장함 자 그럼 a.exe라는 프로그램을 실행시킨다고하면 OS가 IO버스로 하드디스크에 있는 a.exe를 RAM에 COPY시킴 그러면 CPU는 RAM에 있는 프로세스의 명령어들을 하나씩 FETCH함 FETCH한 정보는 CPU에 버스 인터페이스를 통해 레지스터에 DECODE함 레지스터에 저장된 정보를 ALU가 EXCUTION함 이 구조를 STORED PROGRAM CONCEPT라고 함 (폰노이만 구조라고도 함) 그리고 이런 하나의 동작 동작들을 클럭이라고 하고 이는 클럭발생기에 의해 클럭이 생성됨 클럭발생기는 각 장치별로 있고 장치별 최소 클럭이 컴퓨터 전체적인 성능이 됨 자 이제부터는 각 명령어들을 직접 설계해볼거임 명령어를 설계하려면 우선 레지스터정의가 필요함 r0 r1 r2 r3 을 범용 r4 r5 r6 r7 을 각 addr ir 등으로 쓰는데 아직 안 배움 그리고 명령어 함수를 정의함 ADD 001 LOAD 010 MIN 011 등등과 같이 함 그래서 명령어조합을 함 ex) ADD r1 r2 r3 -> r2 r2에 있는 정보를 더해서 r1에 저장하라 이렇게 하려면 r2 r3에 정보를 저장해야하니까 LOAD가 필요함 LOAD는 RAM으로부터 데이터를 REG에 불러오는것 반대로 STORE는 REG -> RAM임 64비트 버스라면, 명령어가 64비트라는 말인데 그 말은 명령어 조합이 64비트 이내란 말이고 그 말은 각 조합이 64비트를 넘어선 안 된다는 말이 된다. 그렇다면 조합중 하나인 피연산자 or 주소 등이 64비트로 표현하는 경우면 어떻게 해야하나? 클럭생성은 누가 하는가? LOAD명령어와 STORE의 필요성 -> 명령어가 제한되어있ㅇ니까 LOAD나 STORE 명령어는 주소값을 갖고 하는데,,,, 명령어는 64비트잖아? 근데 주소값도 64비트야 그럼 어떻게 해? LOAD r1 0x10 LOAD r2 0x20 ADD r3 r1 r2 STORE r3 0x30 direct mode indirect mode int a = 10; // 0x0010 int b = 20; //0x0100 int c = 0; // 0x0020 c = a + b; LOAD r1 0x0010 MUL r0 4 4 MUL r2 4 4 MUL r3 r0 r2 STORE r3 0x0030 LOAD r2 0x0030 ADD r3 r1 r2 RAM보다 프로세스 크기가 커지면? - 우선은 가상 메모리 덕분에 된다고 생각하자. 프로세스가 뭐지?? - 메모리구조 + 레지스터 Set - 프로세스별로 독립적으로 할당받는 모든 메모리들 프로세스 스케쥴러 - CPU는 한 순간에 하나의 프로세스만 실행 가능하다. - 그런데 여러 프로세스를 사용하려면? - 프로세스들을 교체해줘야한다. - 근데 스케쥴러 자체도 프로세스다. - 그래서 스케쥴러가 동작되는 시간에도 CPU는 다른일을 못한다. - 따라서 가급적 스케쥴러 호출을 적게할 수록 좋다. 이 상태전이는 스케쥴러가 선택한다. Running state : CPU에 올라와 있는 상태 - Ready state : Running 하고싶은 상태 - Blocked state I/O연산은 CPU가 하는게 아님!! I/O를 하고 있으면 Blocked로 넘김 컨텍스트 스위칭 - 프로세스가 running state로 넘어갈 때 프로세스 종속된 데이터들과 MainMemory에 있는 데이터를 교환하는ㄷ.. 커널 오브젝트 - 커널에 의해 관리되는 리소스 정보를 담고 있는 데이터 블록 ( 파이프, 프로세스, 쓰레드, 파일 등) - 프로세스를 관리하려면, 프로세스 관련된 프로세스 커널 오브젝트가 생성됨 - 파일을 생성하면 그 파일에 해당하는 파일 커널 오브젝트가 생성됨 - 쓰레드도 뭐도 다 마찬가지임 커널 오브젝트의 특정 요소를 바꾸기위해선? -> 커널 오브젝트에 직접 접근은 안 되고, 간접적으로 접근해야함 -> 그래서 그거에 관련된 API를 제공해줌 ex) upc() -> 이때 인자로 커널 오브젝트를 넘겨줄 순 없음 (다 막아놨기때문에) -> 그래서 우리가 커널 오브젝트가 생성될 때 그에 관련된 핸들을 반환하는데 (근데 또 각 리소스별로다름) -> 그 핸들을 API에 전달하는 방식으로 함 -> 한 프로세스가 생성이 되면 그 프로세스는 핸들테이블에 핸들을 생성하고 그 테이블은 핸들 값이랑 그 대상체의 주소가 담겨있음 -> 그 핸들 테이블에는 자식 프로세스의 핸들도 있고 자기의 핸들도 있음 -> 자식 프로세스 만들때 자식의 핸들값을 부모가 가짐 -> 즉 핸들테이블은 각 프로세스에 종속적임 -> 자식 프로세스가 종료되어도 커널 오브젝트는 사라지지 않음! UC가 1이라서 -> UC는 자기한테 참조되고 있느 ㄴ애들 -> main에 있는 return 은 커널 오브젝트에 들어감!!!!!!!! (종료 상태를 저장함) -> 그래서 부모가 자식프로세스의 상태 확인할 때 자식의 핸들을 통해 자식의 커널 오브젝트를 접근해 해당 프로세스의 상태를 체크 -> 근데 사실은 자기 자신의 핸들 정보는 자기 핸들 테이블에 저장되지 않음 -> 그럼 자기 핸들을 가져오려면?getCurrentProcess()가 있는데 이는 -1이 return 되는데 이건 진짜 핸들이 아니라 그냥 자기 자신을 나타내는 핸들의 상수임 -> closehandle을 하면 부모가 자식을 포기하는 형태가됨, 그럼 얘들은 부-모 자식관계가 아니라 그냥 부모에 있는 핸들테이블에서 자식 핸들을 제거하는 것 -> 좀비 프로세스 생성을 방지할 수 이씀 프로세스간 통신!! IPC -> 서로 통신하는 방식은 특정 데이터 영역을 두고 그 영역을 공유하는 형태임 -> 이때 사용하는 기법이 메일 슬롯 -> 이는 단방향 특성임 Sender -> Receiver 로만 데이터 전송 가능 -> Broadcasting 가능 함 -> 결국 메일슬롯도 파일 하나 -> ReadFile, WriteFile - 프로세스 만들면 커널 오브젝트가 생성되고 그 오브젝트의 상태는 Non-signaled가 됨 - Non-signaled상태는 Running 상태라는걸 나타냄","categories":[],"tags":[]},{"title":"Algorithm/bfsdfs","slug":"Algorithm/bfsdfs","date":"2020-05-05T14:53:48.246Z","updated":"2020-05-05T15:11:32.995Z","comments":true,"path":"2020/05/05/Algorithm/bfsdfs/","link":"","permalink":"https://johwanhee.github.io/2020/05/05/Algorithm/bfsdfs/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152void dfs(Vertex* v)&#123; if(!v) &#123; return; &#125; if(v-&gt;visited) &#123; return; &#125; printf(\"%c\", v-&gt;data); Edge* e = v-&gt;adjacencyList; v-&gt;visited = 1; while (e) &#123; dfs(e-&gt;to); e = e-&gt;next; &#125;&#125;void bfs(Vertex* root)&#123; if(!root) &#123; return; &#125; Queue* q = create_queue(); enQueue(q, root); while(!isEmpty(q)) &#123; Vertex* v = deQueue(q); printf(\"%c\", v-&gt;data); v-&gt;visited = 1; Edge* e = v-&gt;adjacencyList; while(e) &#123; if(!e-&gt;to-&gt;visited) &#123; enQueue(q, e-&gt;to); &#125; e = e-&gt;next; &#125; &#125; destory_queue(q);&#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}